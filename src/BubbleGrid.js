import animate;
import src.config as config;
import ui.View as View;
import ui.ImageView as ImageView;
import math.geom.Point as Point;

// N is the maximum number of bubbles per line.
// Abbreviated for abstraction and to refer to it in the rest of the code more easily
var N = config.nbBubblesPerLine;

var MAX_BUBBLE_INDEX = 2 * N - 2;

var BUBBLE_SPACE = config.bubbleSpace;
var BUBBLE_DIMENSION = config.bubbleDimension;
var BUBBLE_COLLISION_DIMENSION = config.bubbleCollisionDimension;

var NB_STARTING_LINES = config.nbStartingLines;

// Top half of bubbles on the top line are off-screen
var MAX_GRID_HEIGHT = config.maxGridHeight;
var MAX_NB_LINES = config.maxNbLines;
var NB_BUBBLE_TYPES = config.nbBubbleTypes;

var GRID_TOP = config.gridTop;

/* The grid contains an array of lines.
 * Each line is an array of bubbles.
 * The reason for using arrays is for fast access purpose.
 * Also, all the grid methods seemed reasonably easy to implement using only arrays to represent the grid.
 *
 * Lines are given generation order based indexes (labelled "j").
 * (e.g lines generated first, second and third are respectively given indexes 0, 1 and 2)
 * Number of bubbles in a line can be either N or N-1 depending on line index.
 * A possible layout when N = 10 is (where number represent bubble types):
 *      2-2-2-2-2-0-0-2-4-4
 *      -2-2-2-2-2-0-2-2-4-
 *      2-2-2-2-2-2-2-2-2-0
 * (If it's confusing just launch the game and look at the bubbles)
 *
 * The bubbles indexes (labelled "i") are computed with respect to
 * their logical position in their line and their line indexes (j), as follows:
 *
 *      j     |       i
 *     odd    |   -1-3-5-7-...
 *     even   |   0-2-4-6-8-...
 * (dashes indicate unused indexes)
 *
 * Bubble indexes are in the inveral [0, 2 * N - 2]
 * Some indexes remain unused but that's fine
 * The reason for using such an indexing is to make the computation of the visual position of a bubble
 * with respect to its logical position in a line independant from the type of lines it belongs to.
 */

var Coordinates = Class(function () {
  this.init = function (i, j) {
    this.i = i;
    this.j = j;
  };
});

var GridBubble = Class(ImageView, function (supr) {
  this.init = function (opts) {
    supr(this, 'init', [opts]);

    this.type = opts.type;
    this.i = opts.i;
    this.j = opts.j;

    // Boolean used to determine whether the bubble
    // has been visited during the matching phase
    // or the removing phase
    this.visited = false;
  };
});

var BubbleLine = Class(function () {
  this.init = function (j) {
    this.j = j;
    this.bubbles = new Array(MAX_BUBBLE_INDEX + 1);
    this.nbBubbles = 0;
  };

  this.addBubble = function (bubble) {
    this.bubbles[bubble.i] = bubble;
    this.nbBubbles += 1;

    if (this.nbBubbles > N) {
      console.error('Noooo! number of bubble is too high!');
    }
  };

  this.removeBubble = function (bubble) {
    this.bubbles[bubble.i] = null;
    this.nbBubbles -= 1;

    if (this.nbBubbles < 0) {
      console.error('Noooo! number of bubble is too low!');
    }
  };
});

var BubbleGrid = exports = Class(View, function (supr) {
  this.init = function (opts) {
    supr(this, 'init', [opts]);
    this.build();
  };

  this.build = function () {
    // Grid position is defined in a way that makes it easy to compute a bubble visual position
    // with respect to its logical position (i,j) in the grid.
    // The requirement is that a bubble in logical position (i,j) = (0,0)
    // should be place in visual position (x,y) = (0,0) in local grid space coordinate
    this.style.x = 0.5 * BUBBLE_SPACE;
    this.style.y = GRID_TOP;

    // Coefficient determining the likelihood of generating a bubble of a different type
    // than its directly neighouring bubbles.
    // Low diversity implies an homogenous board will be generated
    // High diversity implies an heterogeneous board will be generated
    // The coefficient is used as part of a difficulty mechanism
    // and will increase over time to increase difficulty.
    // Has to be in range ]0,+oo[
    this._diversity = 0.2;

    this._lines = [];
    this._j = MAX_NB_LINES; // making sure that line generated by thrown bubbles still have positive j

    // Populating grid
    for (var l = 0; l < NB_STARTING_LINES; l += 1) {
      this.addLine();
    }
  };


  this._getLineIndex = function (j) {
    // Getting line array index with respect to line generation index
    if (this._lines.length === 0) {
      return this._j;
    }

    var lowerJ = this._lines[0].j;
    return j - lowerJ;
  };

  // For debugging purpose
  this.logGrid = function () {
    for (var l = this._lines.length - 1; l >= 0; l -= 1) {
      var log = '';
      var line = this._lines[l];
      var bubbles;
      if (line) {
        bubbles = line.bubbles;
      } else {
        bubbles = [];
      }

      for (var i = 0; i <= MAX_BUBBLE_INDEX; i += 1) {
        var bubble = bubbles[i];
        if (bubble) {
          log += bubble.type.toString();
        } else {
          log += '-';
        }
      }
      console.log(log);
    }
  };

  this._getNeighbours = function (i, j) {
    var neighbours = [];

    // Actual index in the array of lines
    var lineIndex = this._getLineIndex(j);

    // Fetching closests neighbours

    // Neighbours on same line
    if (this._lines[lineIndex]) {
      var bubblesOnLine = this._lines[lineIndex].bubbles;
      if (bubblesOnLine[i - 2]) { neighbours.push(bubblesOnLine[i - 2]); }
      if (bubblesOnLine[i + 2]) { neighbours.push(bubblesOnLine[i + 2]); }
    }

    // Neighbours in line above
    var indexAbove = lineIndex + 1;
    if (this._lines[indexAbove]) {
      var bubblesAbove = this._lines[indexAbove].bubbles;
      if (bubblesAbove[i - 1]) { neighbours.push(bubblesAbove[i - 1]); }
      if (bubblesAbove[i]) { neighbours.push(bubblesAbove[i]); }
      if (bubblesAbove[i + 1]) { neighbours.push(bubblesAbove[i + 1]); }
    }

    // Neighbours in line below
    var indexBelow = lineIndex - 1;
    if (this._lines[indexBelow]) {
      var bubblesBelow = this._lines[lineIndex - 1].bubbles;
      if (bubblesBelow[i - 1]) { neighbours.push(bubblesBelow[i - 1]); }
      if (bubblesBelow[i]) { neighbours.push(bubblesBelow[i]); }
      if (bubblesBelow[i + 1]) { neighbours.push(bubblesBelow[i + 1]); }
    }

    // console.log('neighbours of (', i, j, ') are', neighbours)  
    return neighbours;
  };

  this._createBubble = function (type, i, j) {
    var pivot = BUBBLE_DIMENSION / 2;
    var bubble = new GridBubble({
      superview: this,
      image: config.bubbleImages[type],
      type: type,
      i: i,
      j: j,
      x: i * BUBBLE_SPACE / 2,
      y: -j * BUBBLE_SPACE,
      width: BUBBLE_DIMENSION,
      height: BUBBLE_DIMENSION,
      anchorX: pivot,
      anchorY: pivot,
      offsetX: -pivot,
      offsetY: -pivot
    });

    return bubble;
  };

  this._selectBubbleType = function (i, j) {
    // Running a roulette wheel selection algorithm
    // I recommand anyone who doesn't know it to check it out:
    // https://en.wikipedia.org/wiki/Fitness_proportionate_selection for reference
    // (I think it's a pertinent heuristic to balance difficulty for some puzzle games)
    var neighbours = this._getNeighbours(i, j);

    var totalChance = NB_BUBBLE_TYPES * this._diversity;
    var chancePerType = new Array(NB_BUBBLE_TYPES).fill(this._diversity);
    for (var n = 0; n < neighbours.length; n += 1) {
      var neighbour = neighbours[n];
      chancePerType[neighbour.type] += 1;
      totalChance += 1;
    }

    var selection = 0;
    var remainingChance = Math.random() * totalChance - chancePerType[0];
    while (selection < NB_BUBBLE_TYPES && remainingChance > 0) {
      selection += 1;
      remainingChance -= chancePerType[selection];
    }

    if (selection === NB_BUBBLE_TYPES) {
      // Due to rounding errors it might possible to end up in this situation
      // (not observed in the context of this game, just experienced it in past projects)
      return selection - 1;
    }

    return selection;
  };

  this.addLine = function () {
    var j = ++this._j;
    var line = new BubbleLine(j);
    this._lines.push(line);

    var lineIndexIsEven = (j % 2 === 0);
    var startingI = lineIndexIsEven ? 0 : 1;
    for (var i = startingI; i <= MAX_BUBBLE_INDEX; i += 2) {
      var bubbleType = this._selectBubbleType(i, j);
      var bubble = this._createBubble(bubbleType, i, j);
      line.addBubble(bubble);
    }

    animate(this)
      .now({ y: BUBBLE_SPACE * j + GRID_TOP }, 1000, animate.easeOutBounce);

    return this._lines.length >= MAX_NB_LINES;
  };

  this._getMatchingBubbles = function (bubble) {
    var searchedType = bubble.type;
    bubble.visited = true;

    // Recursively visiting neighbours with same type until they have all been visited
    var matchingBubbles = [bubble];
    var visitedBubbles = [bubble];
    var bubblesToVisit = [bubble];
    while (bubblesToVisit.length > 0) {
      var visitedBubble = bubblesToVisit.pop(); // DPS
      var neighbours = this._getNeighbours(visitedBubble.i, visitedBubble.j);
      for (var n = 0; n < neighbours.length; n += 1) {
        var neighbour = neighbours[n];
        if (!neighbour.visited) {
          if (neighbour.type === searchedType) {
            matchingBubbles.push(neighbour);
            bubblesToVisit.push(neighbour);
          }
          neighbour.visited = true;
          visitedBubbles.push(neighbour);
        }
      }
    }

    // Resetting visited bubbles
    for (var b = 0; b < visitedBubbles.length; b += 1) {
      visitedBubbles[b].visited = false;
    }

    // Recursively visiting all neighbours
    visitedBubbles = [bubble];
    bubblesToVisit = [bubble];
    while (bubblesToVisit.length > 0) {
      var visitedBubble = bubblesToVisit.shift(); // BFS, to get collided bubbles in increasing order of distance
      // var visitedBubble = bubblesToVisit.pop(); // DPS
      var neighbours = this._getNeighbours(visitedBubble.i, visitedBubble.j);
      for (var n = 0; n < neighbours.length; n += 1) {
        var neighbour = neighbours[n];
        if (!neighbour.visited) {
          neighbour.visited = true;
          bubblesToVisit.push(neighbour);
          visitedBubbles.push(neighbour);
        }
      }
    }

    // Resetting visited bubbles
    for (var b = 0; b < visitedBubbles.length; b += 1) {
      visitedBubbles[b].visited = false;
    }

    return {
      matchingBubbles: matchingBubbles,
      collidedBubbles: visitedBubbles
    }
  };

  /*
   * Attaches the given thrown bubble to the grid
   * Returns the array of matching bubbles
   */
  this.attachThrownBubble = function (thrownBubble) {
    // Thrown bubble will either be added to the grid
    // or will create a match that will explode bubbles of the same type
    // and may be detach bubbles of other types

    // Determining where the thrown bubble should land in the logical grid
    // Using some back tracing mechanism because with a bad frame rate
    // it should be possible to go through the bubbles
    // Also, animations could make the position of bubbles unpredictable
    var position = this._globalToLocalVisualSpace(thrownBubble.style.x, thrownBubble.style.y);

    // Normalizing bubble velocity in "bubble space"
    var vx = thrownBubble.velocityX;
    var vy = thrownBubble.velocityY;
    var v = Math.sqrt(vx * vx + vy * vy);

    // (dx, dy) is half a bubble space unit in the opposite direction of the velocity
    var dx = -vx * 0.5 * BUBBLE_SPACE / v;
    var dy = -vy * 0.5 * BUBBLE_SPACE / v;

    var lowerI = 0;
    var upperI = MAX_BUBBLE_INDEX;

    var lowerJ = this._lines[0].j - 1;
    var upperJ = this._lines[this._lines.length - 1].j;

    var coordinates;
    var lineIndex;
    var positionFound = false;
    while (!positionFound) {
      // TODO: handle positions (i,j) out of bounds? Seems a possible situation...
      // Idea to fix it properly: reverse the side collisions
      // For now, bounding the logical position
      coordinates = this._visualToLogicalSpace(position);
      coordinates.i = Math.min(upperI, Math.max(lowerI, coordinates.i));
      coordinates.j = Math.min(upperJ, Math.max(lowerJ, coordinates.j));

      if ((coordinates.i + coordinates.j) & 1 === 1) {
        // Coordinates i and j are incompatible
        // Shifting i
        var fractionalI = 2 * position.x / BUBBLE_SPACE;
        if (coordinates.i - fractionalI > 0) {
          coordinates.i -= 1;
          if (coordinates.i < lowerI) {
            coordinates.i += 2;
          }
        } else {
          coordinates.i += 1;
          if (coordinates.i > upperI) {
            coordinates.i -= 2;
          }
        }

      }

      // Checking whether the logical position is taken by a bubble
      lineIndex = this._getLineIndex(coordinates.j);

      var line = this._lines[lineIndex];
      if (line && line.bubbles[coordinates.i]) {
        // Position taken
        position.x += dx;
        position.y += dy;
      } else {
        positionFound = true;
      }
    }

    // Adding thrown bubble to the grid
    var gridBubble = this._createBubble(thrownBubble.type, coordinates.i, coordinates.j);
    if (lineIndex < 0) {
      // If the bubble lands below all existing lines,
      // then a new line need to be created
      var lowerJ = this._lines[0].j;
      this._lines.unshift(new BubbleLine(lowerJ - 1));
      lineIndex = 0;
    }
    this._lines[lineIndex].addBubble(gridBubble);

    // Removing thrown bubble from its current view
    thrownBubble.removeFromSuperview();

    return this._getMatchingBubbles(gridBubble);
  };

  this._visualToLogicalSpace = function (position) {
    var i = Math.round(2 * position.x / BUBBLE_SPACE);

    // deltaY represents the distance the grid is to where it should be 
    // var deltaY = (BUBBLE_SPACE * this._j + GRID_TOP) - this.style.y;
    // var j = -Math.round((deltaY + position.y) / BUBBLE_SPACE);
    var j = -Math.round(position.y / BUBBLE_SPACE);
    return new Coordinates(i, j);
  };

  this.localToGlobalVisualSpace = function (x, y) {
    return new Point(x + this.style.x, y + this.style.y);
  };

  this._globalToLocalVisualSpace = function (x, y) {
    return new Point(x - this.style.x, y - this.style.y);
  };

  /*
   * Returns whether the thrown bubble touches the grid
   */
  this.isThrownBubbleTouchingGrid = function (thrownBubble) {
    // Determining whether the thrown bubble is attaching to any bubble on the grid
    // Criteria for a thrown bubble to attach to grid bubble is:
    // - the bubble reached the top of the gid
    // - the bubble physically overlaps a grid bubble

    if (thrownBubble.style.y < GRID_TOP) {
      // Thrown bubble touching top of the grid
      return true;
    }

    // The thrown bubble's position is in global space coordinates
    // transforming it to grid coordinates
    var position = this._globalToLocalVisualSpace(thrownBubble.style.x, thrownBubble.style.y);

    // Corresponding logical (i, j) coordinates in the grid
    var coordinates = this._visualToLogicalSpace(position);

    // Ranges of indexes covered in terms of line and bubble indexes
    var minI = coordinates.i - 2;
    var maxI = coordinates.i + 2;
    var minJ = coordinates.j - 1;
    var maxJ = coordinates.j + 1;

    // Determining if the thrown bubble touches any grid bubble

    // Iterating through a 5x3 chunk of bubbles
    // In average testing collision with 0~3 bubbles
    // (probably no need to optimise this out)
    for (var j = minJ; j <= maxJ; j += 1) {
      var lineIndex = this._getLineIndex(j);
      var line = this._lines[lineIndex];
      if (!line) {
        continue;
      }

      var bubbles = line.bubbles;
      for (var i = minI; i <= maxI; i += 1) {
        var bubble = bubbles[i];
        if (!bubble) {
          continue;
        }

        var dx = bubble.style.x - position.x;
        var dy = bubble.style.y - position.y;

        var d = Math.sqrt(dx * dx + dy * dy);

        // Using bubble dimension to determine collision
        if (d < BUBBLE_COLLISION_DIMENSION) {
          return true;
        }
      }
    }

    return false;
  };

  this._removeBubble = function (bubble) {
    var i = bubble.i;
    var j = bubble.j;

    var line = this._lines[this._getLineIndex(j)];
    line.removeBubble(bubble);
    bubble.removeFromSuperview();

    if (line.nbBubbles === 0) {
      // Garbage collecting the lines
      while (this._lines.length > 0 && this._lines[0].nbBubbles === 0) {
        this._lines.shift();
      }
    }
  };

  /*
   * Removes the given bubbles from the grid
   * and returns the list of falling bubbles
   */
  this.removeBubbles = function (bubbleToRemove) {
    // This is the only method where bubbles are removed
    var b, bubble;
    for (b = 0; b < bubbleToRemove.length; b += 1) {
      this._removeBubble(bubbleToRemove[b]);
    }

    // Determining list of falling bubbles
    // Algorithm may be unefficient but good enough
    // Bubbles attached to the top cannot fall
    // (that's against the second amendment or the third law of motion or something)
    // So that's where we start
    var visitedBubbles = [];
    var topLine = this._lines[this._lines.length - 1];
    var upperJ = topLine.j;
    var topBubbles = topLine.bubbles;
    var lineIndexIsEven = (upperJ % 2 === 0);
    var startingI = lineIndexIsEven ? 0 : 1;
    for (var i = startingI; i <= MAX_BUBBLE_INDEX; i += 2) {
      bubble = topBubbles[i];
      if (bubble) {
        bubble.visited = true;
        visitedBubbles.push(bubble);
      }
    }

    // Flowing down the grid to determine which bubbles are indirectly attached to the top
    while (visitedBubbles.length > 0) {
      bubble = visitedBubbles.pop();
      var neighbours = this._getNeighbours(bubble.i, bubble.j);
      for (var n = 0; n < neighbours.length; n += 1) {
        var neighbour = neighbours[n];
        if (!neighbour.visited) {
          neighbour.visited = true;
          visitedBubbles.push(neighbour);
        }
      }
    }

    // Going through all the bubbles to identify which ones are falling (not visited ones)
    var fallingBubbles = [];

    // Making copy of lines because they could be removed within the loop
    var linesCopy = this._lines.slice();
    for (var l = 0; l < linesCopy.length; l += 1) {
      var line = linesCopy[l];
      var bubbles = line.bubbles;
      for (var i = 0; i <= MAX_BUBBLE_INDEX; i += 1) {
        bubble = bubbles[i];
        if (bubble) {
          if (bubble.visited) {
            bubble.visited = false;
          } else {
            // Falling bubble!
            this._removeBubble(bubble);
            fallingBubbles.push(bubble);
          }
        }
      }
    }

    return fallingBubbles;
  };

});

